package main

import (
	"fmt"
	"io/ioutil"
	"math"
	"os"
	"path"
	"reflect"
	"regexp"
	"sort"
	"strconv"
	"strings"

	. "github.com/candid82/joker/core"
	_ "github.com/candid82/joker/std/html"
	_ "github.com/candid82/joker/std/string"
)

const hextable = "0123456789abcdef"
const masterFile = "a_code.go"
const codePattern = "a_%s_code.go"
const dataPattern = "a_%s_data.go"

type GenEnv struct {
	Statics   *[]string
	Runtime   *[]string
	Imports   *Imports
	Generated map[interface{}]interface{} // key{reflect.Value} => map{string} that is the generated name of the var; else key{name} => map{obj}
}

func newCodeEnv(cwe *CodeWriterEnv) *CodeEnv {
	return &CodeEnv{
		CodeWriterEnv: cwe,
		BaseMappings:  map[*string]*Var{},
		Need:          map[string]Finisher{},
		Generated:     map[interface{}]interface{}{},
	}
}

func parseArgs(args []string) {
	length := len(args)
	stop := false
	missing := false
	var i int
	for i = 1; i < length; i++ { // shift
		switch args[i] {
		case "--verbose":
			Verbose++
		default:
			if strings.HasPrefix(args[i], "-") {
				fmt.Fprintf(Stderr, "Error: Unrecognized option '%s'\n", args[i])
				os.Exit(2)
			}
			stop = true
		}
		if stop || missing {
			break
		}
	}
	if missing {
		fmt.Fprintf(Stderr, "Error: Missing argument for '%s' option\n", args[i])
		os.Exit(3)
	}
	if i < length {
		fmt.Fprintf(Stderr, "Error: Extranous command-line argument '%s'\n", args[i])
		os.Exit(4)
	}
}

func main() {
	// Hashmaps depend on the hashes of objects to find keys;
	// whereas this code (code.go, mainly) depends on stability of
	// data. Since object hashes depend (in some cases) on their
	// pointers, they're not always stable. So don't generate
	// hashmaps! TODO: Try removing this after other stuff done.
	HASHMAP_THRESHOLD = math.MaxInt64

	parseArgs(os.Args)

	codeWriterEnv := &CodeWriterEnv{
		BaseStrings: StringPool{},
		Need:        map[string]Finisher{},
		Generated:   map[interface{}]interface{}{},
	}
	for k, v := range STRINGS {
		codeWriterEnv.BaseStrings[k] = v
	}
	InitInternalLibs()

	envForNs := map[string]*CodeEnv{}

	for _, f := range CoreSourceFiles {
		nsName := CoreNameAsNamespaceName(f.Name)
		nsNamePtr := STRINGS.Intern(nsName)

		env := newCodeEnv(codeWriterEnv)

		if ns, found := GLOBAL_ENV.Namespaces[nsNamePtr]; found {
			if _, exists := envForNs[nsName]; exists {
				continue // Already processed; this is probably a linter*.joke file
			}
			fmt.Printf("FOUND ns=%s file=%s mappings=%d\n", nsName, f.Filename, len(ns.Mappings()))
			for k, v := range ns.Mappings() {
				env.BaseMappings[k] = v
			}
		} else {
			fmt.Printf("READING ns=%s file=%s\n", nsName, f.Filename)
		}

		envForNs[nsName] = env

		ProcessCoreSourceFileFor(f.Name)

		ns := GLOBAL_ENV.Namespaces[nsNamePtr]
		fmt.Printf("READ ns=%s mappings=%d\n", nsName, len(ns.Mappings()))
		env.Namespace = ns

		if false {
			break // TODO: Handle this differently, or at least later than a_code.go generation
		}
	}

	if Verbose > 1 {
		fmt.Fprintln(os.Stderr, "gen_code:main(): After loading source files:")
		Spew()
	}

	const fileTemplate = `
// Generated by gen_code. Don't modify manually!

// +build fast_init

package core

func init() {
	{name}NamespaceInfo = internalNamespaceInfo{generated: {name}NamespaceInfo.generated, available: true}
}
`

	for nsNamePtr, ns := range GLOBAL_ENV.Namespaces {
		nsName := *nsNamePtr

		GLOBAL_ENV.SetCurrentNamespace(ns)

		env := envForNs[nsName]
		if env == nil {
			if Verbose > 0 {
				fmt.Printf("SKIPPING ns=%s mappings=%d\n", nsName, len(ns.Mappings()))
			}
			continue
		}

		if Verbose > 0 {
			fmt.Printf("EMITTING ns=%s mappings=%d\n", nsName, len(ns.Mappings()))
		}

		filename := CoreSourceFilename[nsName]
		name := filename[0 : len(filename)-5] // assumes .joke extension
		codeFile := fmt.Sprintf(codePattern, name)
		fileContent := strings.ReplaceAll(fileTemplate[1:], "{name}", name)
		ioutil.WriteFile(codeFile, []byte(fileContent), 0666)
	}

	statics := []string{}
	runtime := []string{}
	imports := NewImports()

	genEnv := &GenEnv{
		Statics:   &statics,
		Runtime:   &runtime,
		Imports:   imports,
		Generated: map[interface{}]interface{}{},
	}

	genEnv.emitVar("STR", STR)
	genEnv.emitVar("STRINGS", STRINGS)
	genEnv.emitVar("SYMBOLS", SYMBOLS)
	genEnv.emitVar("SPECIAL_SYMBOLS", SPECIAL_SYMBOLS)
	genEnv.emitVar("KEYWORDS", KEYWORDS)
	genEnv.emitVar("TYPE", TYPE)
	genEnv.emitVar("TYPES", TYPES)
	genEnv.emitVar("GLOBAL_ENV", GLOBAL_ENV)

	sort.Strings(statics)

	r := strings.Join(runtime, "\n")
	if r != "" {
		r = fmt.Sprintf(`

func init() {
%s
}`,
			r)

	}

	imp := QuotedImportList(imports, "\n")
	if imp[0] == '\n' {
		imp = imp[1:]
	}

	var tr = [][2]string{
		{"{imports}", imp},
		{"{statics}", strings.Join(statics, "\n")},
		{"{runtime}", r},
	}

	fileContent := `
// Generated by gen_code. Don't modify manually!

// +build fast_init

package core

import (
{imports}
)

{statics}
{runtime}
`[1:]

	for _, t := range tr {
		fileContent = strings.Replace(fileContent, t[0], t[1], 1)
	}

	ioutil.WriteFile(masterFile, []byte(fileContent), 0666)
}

func (genEnv *GenEnv) emitVar(name string, obj interface{}) {
	if _, found := genEnv.Generated[name]; found {
		return // panic(fmt.Sprintf("already generated %s", name))
	}
	genEnv.Generated[name] = nil
	v := reflect.ValueOf(obj)
	*genEnv.Statics = append(*genEnv.Statics, fmt.Sprintf(`
var %s %s = %s`[1:],
		name, coreTypeName(v), genEnv.emitValue(name, v)))
	genEnv.Generated[name] = obj
}

func (genEnv *GenEnv) emitMembers(target string, name string, obj interface{}) (members []string) {
	v := reflect.ValueOf(obj)
	kind := v.Kind()
	switch kind {
	case reflect.Map:
		if v.IsNil() {
			return
		}
		keys := v.MapKeys()
		elemType := v.Type().Elem()
		for _, key := range keys {
			k := genEnv.emitValue("", key)
			vi := v.MapIndex(key)
			v := genEnv.emitValue(fmt.Sprintf("%s[%s]%s", target, k, assertValueType(elemType, vi)), vi)
			if isNil(v) {
				continue
			}
			members = append(members, fmt.Sprintf(`
	%s: %s,`[1:],
				k, v))
		}
	case reflect.Struct:
		vt := v.Type()
		numMembers := v.NumField()
		for i := 0; i < numMembers; i++ {
			vtf := vt.Field(i)
			vf := v.Field(i)
			val := genEnv.emitValue(fmt.Sprintf("%s.%s%s", target, vtf.Name, assertValueType(vtf.Type, vf)), vf)
			if val == "" {
				continue
			}
			members = append(members, fmt.Sprintf(`
	%s: %s,`[1:],
				vtf.Name, val))
		}
	default:
		panic(fmt.Sprintf("unsupported type %T for %s", obj, name))
	}
	sort.Strings(members)
	return
}

func (genEnv *GenEnv) emitValue(target string, v reflect.Value) string {
	v = UnsafeReflectValue(v)
	if v.IsZero() {
		return ""
	}

	switch pkg := path.Base(v.Type().PkgPath()); pkg {
	case "reflect":
		t := coreTypeString(fmt.Sprintf("%s", v))
		components := strings.Split(t, ".")
		if len(components) == 2 {
			// not handling more than one component yet!
			importedAs := AddImport(genEnv.Imports, "", components[0], true)
			t = fmt.Sprintf("%s.%s", importedAs, components[1])
		}
		el := ""
		if t[0] != '*' {
			t = "*" + t
			el = ".Elem()"
		}
		importedAs := AddImport(genEnv.Imports, "", "reflect", true)
		return fmt.Sprintf("%s.TypeOf((%s)(nil))%s", importedAs, t, el)
	case "core":
	case ".":
	default:
		panic(fmt.Sprintf("unexpected PkgPath `%s' for %+v", pkg, v.Interface()))
	}

	switch v.Kind() {
	case reflect.Interface:
		if v.IsNil() {
			return ""
		}
		return genEnv.emitValue(target, v.Elem())

	case reflect.Ptr:
		return genEnv.emitPtrTo(target, v)

	case reflect.Bool:
		if v.Bool() {
			return "true"
		}
		return "false"

	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
		return fmt.Sprintf("%d", v.Int())

	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
		return fmt.Sprintf("%d", v.Uint())

	case reflect.Float64:
		return strconv.FormatFloat(v.Float(), 'x', -1, 64)

	case reflect.String:
		return strconv.Quote(v.String())

	case reflect.Slice, reflect.Array:
		return fmt.Sprintf(`%s{%s}`, coreTypeName(v), genEnv.emitSlice(target, v))

	case reflect.Struct:
		typeName := coreTypeName(v)
		obj := v.Interface()
		if p, yes := obj.(Proc); yes {
			return genEnv.emitProc(target, p)
		}
		if obj == nil {
			return ""
		}
		return fmt.Sprintf(`
%s{%s}`[1:],
			typeName, joinMembers(genEnv.emitMembers(target, typeName, obj)))

	case reflect.Map:
		typeName := coreTypeName(v)
		obj := v.Interface()
		if obj == nil {
			return ""
		}
		return fmt.Sprintf(`
%s{%s}`[1:],
			typeName, joinMembers(genEnv.emitMembers(target, typeName, obj)))

	default:
		return fmt.Sprintf("nil /* UNKNOWN TYPE obj=%T v=%s v.Kind()=%s vt=%s */", v.Interface(), v, v.Kind(), v.Type())
	}
}

func (genEnv *GenEnv) emitProc(target string, p Proc) string {
	fn := ""
	newPackage := ""
	if p.Package != "" {
		newPackage = fmt.Sprintf(`
	Package: %s,
`[1:],
			strconv.Quote(p.Package))
	} else {
		fn = fmt.Sprintf(`
	Fn: %s,
`[1:],
			p.Name)
	}
	return fmt.Sprintf(`
Proc{
%s	Name: %s,
%s}`[1:],
		fn, strconv.Quote(p.Name), newPackage)
}

func (genEnv *GenEnv) emitPtrToRegexp(target string, v reflect.Value) string {
	importedAs := AddImport(genEnv.Imports, "", "regexp", true)
	return fmt.Sprintf(`%s.MustCompile(%s)`, importedAs, strconv.Quote(v.Interface().(*regexp.Regexp).String()))
}

func (genEnv *GenEnv) emitPtrTo(target string, ptr reflect.Value) string {
	if ptr.IsNil() {
		return "nil"
	}

	v := ptr.Elem()
	v = UnsafeReflectValue(v)

	if v.IsZero() {
		return ""
	}

	switch pkg := path.Base(v.Type().PkgPath()); pkg {
	case "regexp":
		return genEnv.emitPtrToRegexp(target, ptr)
	case "core":
	case ".":
	default:
		panic(fmt.Sprintf("unexpected PkgPath `%s' for &%+v", pkg, v.Interface()))
	}

	switch v.Kind() {
	case reflect.Interface:
		if v.IsNil() {
			return "nil"
		}
		return genEnv.emitPtrTo(target, v.Elem())

	default:
		thing, found := genEnv.Generated[v]
		if !found {
			obj := v.Interface()
			name := uniqueId(obj)
			genEnv.Generated[v] = name
			genEnv.emitVar(name, obj)
			return "&" + name
		}
		name := thing.(string)
		status, found := genEnv.Generated[name]
		if !found {
			panic(fmt.Sprintf("cannot find generated thing %s: %+v", name, v.Interface()))
		}
		if status == nil {
			*genEnv.Runtime = append(*genEnv.Runtime, fmt.Sprintf(`
	%s = &%s`[1:],
				target, name))
			return "nil"
		}
		return "&" + name
	}
}

func (genEnv *GenEnv) emitSlice(target string, v reflect.Value) string {
	numEntries := v.Len()
	el := []string{}
	for i := 0; i < numEntries; i++ {
		res := genEnv.emitValue(fmt.Sprintf("%s[%d]", target, i), v.Index(i))
		if res == "" {
			el = append(el, "\tnil,")
		} else {
			el = append(el, "\t"+res+",")
		}
	}
	return joinMembers(el)
}

func coreTypeString(s string) string {
	return strings.Replace(s, "core.", "", 1)
}

func coreTypeName(v reflect.Value) string {
	return coreTypeString(v.Type().String())
}

func coreTypeOf(obj interface{}) string {
	return coreTypeName(reflect.ValueOf(obj))
}

func uniqueId(obj interface{}) string {
	switch obj := obj.(type) {
	case string:
		return "s_" + NameAsGo(obj)
	default:
	}
	return UniqueId(obj, nil)
}

func assertValueType(elemType reflect.Type, r reflect.Value) string {
	if elemType == r.Type() {
		return ""
	}
	return ".(" + coreTypeName(r) + ")"
}

func joinMembers(members []string) string {
	f := strings.Join(members, "\n")
	if f != "" {
		f = "\n" + f + "\n"
	}
	return f
}

func isNil(s string) bool {
	return s == "" || s == "nil"
}

/* Represents an 'import ( foo "bar/bletch/foo" )' line to be produced. */
type Import struct {
	Local       string // "foo", "_", ".", or empty
	LocalRef    string // local unless empty, in which case final component of full (e.g. "foo")
	Full        string // "bar/bletch/foo"
	substituted bool   // Had to substitute a different local name
}

/* Maps relative package (unix-style) names to their imports, non-emptiness, etc. */
type Imports struct {
	LocalNames map[string]string  // "foo" -> "bar/bletch/foo"; no "_" nor "." entries here
	FullNames  map[string]*Import // "bar/bletch/foo" -> ["foo", "bar/bletch/foo"]
}

func NewImports() *Imports {
	return &Imports{map[string]string{}, map[string]*Import{}}
}

/* Given desired local and the full (though relative) name of the
/* package, make sure the local name agrees with any existing entry
/* and isn't already used (picking an alternate local name if
/* necessary), add the mapping if necessary, and return the (possibly
/* alternate) local name. */
func AddImport(imports *Imports, local, full string, okToSubstitute bool) string {
	components := strings.Split(full, "/")
	if imports == nil {
		panic(fmt.Sprintf("imports is nil for %s", full))
	}
	if e, found := imports.FullNames[full]; found {
		if e.Local == local {
			return e.LocalRef
		}
		if okToSubstitute {
			return e.LocalRef
		}
		panic(fmt.Sprintf("addImport(%s,%s) told to to replace (%s,%s)", local, full, e.Local, e.Full))
	}

	substituted := false
	localRef := local
	if local == "" {
		localRef = components[len(components)-1]
	}
	if localRef != "." {
		prevComponentIndex := len(components) - 1
		for {
			origLocalRef := localRef
			curFull, found := imports.LocalNames[localRef]
			if !found {
				break
			}
			substituted = true
			prevComponentIndex--
			if prevComponentIndex >= 0 {
				localRef = components[prevComponentIndex] + "_" + localRef
				continue
			} else if prevComponentIndex > -99 /* avoid infinite loop */ {
				localRef = fmt.Sprintf("%s_%d", origLocalRef, -prevComponentIndex)
				continue
			}
			panic(fmt.Sprintf("addImport(%s,%s) trying to replace (%s,%s)", localRef, full, imports.FullNames[curFull].LocalRef, curFull))
		}
		if imports.LocalNames == nil {
			imports.LocalNames = map[string]string{}
		}
		imports.LocalNames[localRef] = full
	}
	if imports.FullNames == nil {
		imports.FullNames = map[string]*Import{}
	}
	imports.FullNames[full] = &Import{local, localRef, full, substituted}
	return localRef
}

func sortedImports(pi *Imports, f func(k string, v *Import)) {
	var keys []string
	for k, _ := range pi.FullNames {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		v := pi.FullNames[k]
		f(k, v)
	}
}

func QuotedImportList(pi *Imports, prefix string) string {
	imports := ""
	sortedImports(pi,
		func(k string, v *Import) {
			if (v.Local == "" && !v.substituted) || v.Local == path.Base(k) {
				imports += prefix + `"` + k + `"`
			} else {
				imports += prefix + v.LocalRef + ` "` + k + `"`
			}
		})
	return imports
}
