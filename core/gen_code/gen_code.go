package main

import (
	"fmt"
	"io/ioutil"
	"math"
	"reflect"
	"sort"
	"strconv"
	"strings"

	. "github.com/candid82/joker/core"
	_ "github.com/candid82/joker/std/html"
	_ "github.com/candid82/joker/std/string"
)

const hextable = "0123456789abcdef"
const masterFile = "a_code.go"
const codePattern = "a_%s_code.go"
const dataPattern = "a_%s_data.go"

type GenEnv struct {
	Statics   *[]string // For reflect-based code in gen_code
	Generated map[interface{}]struct{}
}

func newCodeEnv(cwe *CodeWriterEnv) *CodeEnv {
	return &CodeEnv{
		CodeWriterEnv: cwe,
		BaseMappings:  map[*string]*Var{},
		Namespace:     GLOBAL_ENV.CoreNamespace,
		Need:          map[string]Finisher{},
		Generated:     map[interface{}]interface{}{},
	}
}

func main() {
	// Hashmaps depend on the hashes of objects to find keys;
	// whereas this code (code.go, mainly) depends on stability of
	// data. Since object hashes depend (in some cases) on their
	// pointers, they're not always stable. So don't generate
	// hashmaps! TODO: Try removing this after other stuff done.
	HASHMAP_THRESHOLD = math.MaxInt64

	codeWriterEnv := &CodeWriterEnv{
		BaseStrings: StringPool{},
		Need:        map[string]Finisher{},
		Generated:   map[interface{}]interface{}{},
	}
	for k, v := range STRINGS {
		codeWriterEnv.BaseStrings[k] = v
	}
	InitInternalLibs()

	envForNs := map[string]*CodeEnv{}

	for _, f := range CoreSourceFiles {
		nsName := CoreNameAsNamespaceName(f.Name)
		nsNamePtr := STRINGS.Intern(nsName)

		env := newCodeEnv(codeWriterEnv)

		if ns, found := GLOBAL_ENV.Namespaces[nsNamePtr]; found {
			if _, exists := envForNs[nsName]; exists {
				continue // Already processed; this is probably a linter*.joke file
			}
			fmt.Printf("FOUND ns=%s file=%s mappings=%d\n", nsName, f.Filename, len(ns.Mappings()))
			for k, v := range ns.Mappings() {
				env.BaseMappings[k] = v
			}
		} else {
			fmt.Printf("READING ns=%s file=%s\n", nsName, f.Filename)
		}

		envForNs[nsName] = env

		ProcessCoreSourceFileFor(f.Name)

		ns := GLOBAL_ENV.Namespaces[nsNamePtr]
		fmt.Printf("READ ns=%s mappings=%d\n", nsName, len(ns.Mappings()))

		if false {
			break // TODO: Handle this differently, or at least later than a_code.go generation
		}
	}

	const fileTemplate = `
// Generated by gen_code. Don't modify manually!

// +build fast_init

package core

func init() {
	{name}NamespaceInfo = internalNamespaceInfo{init: {name}Init, generated: {name}NamespaceInfo.generated, available: true}
}

{statics}
func {name}Init() {
{interns}
}
`

	for nsNamePtr, ns := range GLOBAL_ENV.Namespaces {
		nsName := *nsNamePtr

		GLOBAL_ENV.SetCurrentNamespace(ns)

		env := envForNs[nsName]
		if env == nil {
			fmt.Printf("SKIPPING ns=%s mappings=%d\n", nsName, len(ns.Mappings()))
			continue
		}

		fmt.Printf("EMITTING ns=%s mappings=%d\n", nsName, len(ns.Mappings()))
		env.Emit()

		statics, interns := env.Statics, env.Interns

		filename := CoreSourceFilename[nsName]
		name := filename[0 : len(filename)-5] // assumes .joke extension
		codeFile := fmt.Sprintf(codePattern, name)

		if false && codeFile <= masterFile { // TODO: Figure out whether this matters anymore
			panic(fmt.Sprintf("I think Go initializes file-scopes vars alphabetically by filename, so %s must come after %s due to dependencies; rename accordingly",
				codeFile, masterFile))
		}
		fileContent := strings.Replace(strings.Replace(strings.ReplaceAll(fileTemplate[1:], "{name}", name), "{statics}", statics, 1), "{interns}", interns, 1)
		ioutil.WriteFile(codeFile, []byte(fileContent), 0666)
	}

	statics := []string{}

	env := &CodeEnv{
		CodeWriterEnv: codeWriterEnv,
		Namespace:     nil,
		Need:          map[string]Finisher{},
		Generated:     map[interface{}]interface{}{},
	}

	genEnv := &GenEnv{
		Statics:   &statics,
		Generated: map[interface{}]struct{}{},
	}

	for {
		needLen := len(codeWriterEnv.Need)

		for name, obj := range codeWriterEnv.Need {
			if _, ok := codeWriterEnv.Generated[name]; ok {
				continue
			}
			s := obj.Finish(name, env)
			codeWriterEnv.Generated[name] = struct{}{}
			if env.Interns != "" {
				panic(fmt.Sprintf("non-null interns for %s", masterFile))
			}
			if len(env.Need) != 0 {
				panic(fmt.Sprintf("non-null needs for %s", masterFile))
			}
			if s != "" {
				statics = append(statics, s)
			}
		}

		if len(codeWriterEnv.Need) <= needLen {
			break
		}
		fmt.Printf("ONE!! MORE!! TIME!! was %d now %d\n", needLen, len(env.Need))
	}

	stringMappings := []string{}
	for s, _ := range STRINGS {
		q := strconv.Quote(s)
		name := "s_" + NameAsGo(s)
		stringMappings = append(stringMappings, fmt.Sprintf(`
	%s: &%s,`[1:],
			q, name))
		statics = append(statics, fmt.Sprintf(`
var %s string = %s`[1:],
			name, q))
	}
	sort.Strings(stringMappings)

	symbolMembers := genEnv.emitMembers("SYMBOLS", SYMBOLS)
	sort.Strings(symbolMembers)

	specialSymbolMappings := genEnv.emitMembers("SPECIAL_SYMBOLS", SPECIAL_SYMBOLS)
	sort.Strings(specialSymbolMappings)

	keywordMembers := genEnv.emitMembers("KEYWORDS", KEYWORDS)
	sort.Strings(keywordMembers)

	strMembers := genEnv.emitMembers("STR", STR)
	sort.Strings(strMembers)

	typeMappings := []string{}
	typeMembers := []string{}
	for s, ty := range TYPES {
		name := NameAsGo(*s)
		strName := "s_" + name
		typeName := "type_" + name
		typeMappings = append(typeMappings, fmt.Sprintf(`
	&%s: &%s,`[1:],
			strName, typeName))
		typeMembers = append(typeMembers, fmt.Sprintf(`
	%s: &%s,`[1:],
			name, typeName))
		members := joinMembers(genEnv.emitMembers(name, *ty))

		statics = append(statics, fmt.Sprintf(`
var %s Type = Type{%s}`[1:],
			typeName, members))
	}
	sort.Strings(typeMappings)
	sort.Strings(typeMembers)

	sort.Strings(statics)
	r := JoinStringFns(env.Runtime)
	if r != "" {
		r = fmt.Sprintf(`

func init() {
%s
}`,
			r)

	}

	var tr = [][2]string{
		{"{keywordMembers}", strings.Join(keywordMembers, "\n")},
		{"{specialSymbolMappings}", strings.Join(specialSymbolMappings, "\n")},
		{"{strMembers}", strings.Join(strMembers, "\n")},
		{"{stringMappings}", strings.Join(stringMappings, "\n")},
		{"{symbolMembers}", strings.Join(symbolMembers, "\n")},
		{"{typeMembers}", strings.Join(typeMembers, "\n")},
		{"{typeMappings}", strings.Join(typeMappings, "\n")},
		{"{statics}", strings.Join(statics, "\n")},
		{"{runtime}", r},
	}

	fileContent := `
// Generated by gen_code. Don't modify manually!

// +build fast_init

package core

import (
	"io"
	"reflect"
)

var KEYWORDS Keywords = Keywords{
{keywordMembers}
}

var SPECIAL_SYMBOLS map[*string]bool = map[*string]bool{
{specialSymbolMappings}
}

var STR Str = Str{
{strMembers}
}

var STRINGS StringPool = StringPool{
{stringMappings}
}

var SYMBOLS Symbols = Symbols{
{symbolMembers}
}

var TYPE Types = Types{
{typeMembers}
}

var TYPES map[*string]*Type = map[*string]*Type{
{typeMappings}
}

{statics}
{runtime}
`[1:]

	for _, t := range tr {
		fileContent = strings.Replace(fileContent, t[0], t[1], 1)
	}

	ioutil.WriteFile(masterFile, []byte(fileContent), 0666)
}

func (genEnv *GenEnv) emitMembers(name string, obj interface{}) (members []string) {
	v := reflect.ValueOf(obj)
	kind := v.Kind()
	switch kind {
	case reflect.Map:
		if v.IsNil() {
			return
		}
		keys := v.MapKeys()
		for _, key := range keys {
			k := genEnv.emitValue(key)
			v := genEnv.emitValue(v.MapIndex(key))
			if v == "" {
				continue
			}
			members = append(members, fmt.Sprintf(`
	%s: %s,`[1:],
				k, v))
		}
	case reflect.Struct:
		vt := v.Type()
		numMembers := v.NumField()
		for i := 0; i < numMembers; i++ {
			vtf := vt.Field(i)
			val := genEnv.emitValue(v.Field(i))
			if val == "" {
				continue
			}
			members = append(members, fmt.Sprintf(`
	%s: %s,`[1:],
				vtf.Name, val))
		}
	default:
		panic(fmt.Sprintf("unsupported type %T for %s", obj, name))
	}
	return
}

func (genEnv *GenEnv) emitValue(v reflect.Value) string {
	v = UnsafeReflectValue(v)
	if v.IsZero() {
		return ""
	}
	if v.Type().PkgPath() == "reflect" {
		t := coreTypeString(fmt.Sprintf("%s", v))
		el := ""
		if t[0] != '*' {
			t = "*" + t
			el = ".Elem()"
		}
		return fmt.Sprintf("reflect.TypeOf((%s)(nil))%s", t, el) // TODO: Insert correct reflection info here
	}
	switch v.Kind() {
	case reflect.Interface:
		if v.IsNil() {
			return ""
		}
		return genEnv.emitValue(v.Elem())
	case reflect.Ptr:
		return genEnv.emitPtrTo(v.Elem())
	case reflect.Bool:
		if v.Bool() {
			return "true"
		}
		return "false"
	case reflect.Slice, reflect.Array:
		return fmt.Sprintf(`%s{%s}`, coreTypeName(v), genEnv.emitSlice(v))
	case reflect.Uint32:
		return fmt.Sprintf("%d", v.Uint())
	case reflect.String:
		return strconv.Quote(v.String())
	case reflect.Struct:
		typeName := coreTypeName(v)
		obj := v.Interface()
		if obj == nil {
			return ""
		}
		name := uniqueId(obj)
		if _, yes := genEnv.Generated[name]; !yes {
			*genEnv.Statics = append(*genEnv.Statics, fmt.Sprintf(`
var %s %s = %s{%s}`[1:],
				name, typeName, typeName, joinMembers(genEnv.emitMembers(typeName, obj))))
			genEnv.Generated[name] = struct{}{}
		}
		return name
	case reflect.Map:
		typeName := coreTypeName(v)
		obj := v.Interface()
		if obj == nil {
			return ""
		}
		name := uniqueId(obj)
		if _, yes := genEnv.Generated[name]; !yes {
			*genEnv.Statics = append(*genEnv.Statics, fmt.Sprintf(`
var %s %s = %s{%s}`[1:],
				name, typeName, typeName, genEnv.emitMembers(typeName, obj)))
			genEnv.Generated[name] = struct{}{}
		}
		return name
	default:
		return fmt.Sprintf("nil /* UNKNOWN TYPE obj=%T v=%s v.Kind()=%s vt=%s */", v.Interface(), v, v.Kind(), v.Type())
	}
}

func (genEnv *GenEnv) emitPtrTo(v reflect.Value) string {
	v = UnsafeReflectValue(v)
	if v.IsZero() {
		return ""
	}
	if v.Type().PkgPath() == "reflect" {
		return "HEY"
	}
	switch v.Kind() {
	case reflect.Interface:
		if v.IsNil() {
			return ""
		}
		return genEnv.emitPtrTo(v.Elem())
	case reflect.Bool:
		if v.Bool() {
			return "&b_true"
		}
		return "&b_false"
	case reflect.String:
		return "&s_" + NameAsGo(v.String())
	default:
		return "&" + genEnv.emitValue(v)
	}
}

func (genEnv *GenEnv) emitSlice(v reflect.Value) string {
	numEntries := v.Len()
	el := []string{}
	for i := 0; i < numEntries; i++ {
		res := genEnv.emitValue(v.Index(i))
		if res == "" {
			el = append(el, "\tnil,")
		} else {
			el = append(el, "\t"+res+",")
		}
	}
	return joinMembers(el)
}

func coreTypeString(s string) string {
	return strings.Replace(s, "core.", "", 1)
}

func coreTypeName(v reflect.Value) string {
	return coreTypeString(v.Type().String())
}

func uniqueId(obj interface{}) string {
	return "g_" + UniqueId(obj, nil) // TODO: Remove "g_" prefix when no more collisions (with e.g. a_core_code.go) are expected
}

func joinMembers(members []string) string {
	f := strings.Join(members, "\n")
	if f != "" {
		f = "\n" + f + "\n"
	}
	return f
}
