package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	. "github.com/candid82/joker/core"
	. "github.com/candid82/joker/core/gen_common"
	_ "github.com/candid82/joker/std/html"
	_ "github.com/candid82/joker/std/string"
)

func parseArgs(args []string) {
	length := len(args)
	stop := false
	missing := false
	var i int
	for i = 1; i < length; i++ { // shift
		switch args[i] {
		case "--verbose":
			VerbosityLevel++
		default:
			if strings.HasPrefix(args[i], "-") {
				fmt.Fprintf(Stderr, "Error: Unrecognized option '%s'\n", args[i])
				os.Exit(2)
			}
			stop = true
		}
		if stop || missing {
			break
		}
	}
	if missing {
		fmt.Fprintf(Stderr, "Error: Missing argument for '%s' option\n", args[i])
		os.Exit(3)
	}
	if i < length {
		fmt.Fprintf(Stderr, "Error: Extranous command-line argument '%s'\n", args[i])
		os.Exit(4)
	}
}

/* Note: Rather than depend on initialization order, this code allows
/* any order as long as init() functions are not run at the same time
/* (on different threads). In particular, while both a_*_code.go and
/* a_*_data.go set the .generated field, the former (assuming it
/* exists) will always set it to a valid function, while the latter
/* will avoid resetting it (to nil) by preserving the existing value
/* when it initializes the remainder of the internalNamespaceInfo
/* struct. */

const template string = `// Generated by gen_data. Don't modify manually!

// +build !gen_data
{slowInit}
package core

var {name}Data []byte

{lib-code}func init() {
{set-lazy}	{name}Data = []byte("{content}")
}
`

const hextable = "0123456789abcdef"

func main() {
	parseArgs(os.Args)

	namespaces := map[string]struct{}{}

	GLOBAL_ENV.FindNamespace(MakeSymbol("user")).ReferAll(GLOBAL_ENV.CoreNamespace)
	for _, f := range CoreSourceFiles {
		GLOBAL_ENV.SetCurrentNamespace(GLOBAL_ENV.CoreNamespace)
		content, err := ioutil.ReadFile("data/" + f.Filename)
		if err != nil {
			panic(err)
		}
		content, err = PackReader(NewReader(bytes.NewReader(content), f.Name), "")
		PanicOnErr(err)

		dst := make([]byte, len(content)*4)
		for i, v := range content {
			dst[i*4] = '\\'
			dst[i*4+1] = 'x'
			dst[i*4+2] = hextable[v>>4]
			dst[i*4+3] = hextable[v&0x0f]
		}

		dataTemplate := template

		nsName := GLOBAL_ENV.CurrentNamespace().Name.Name()

		libCode := ""
		setLazy := ""
		slowInit := ""
		if _, found := namespaces[nsName]; !found && nsName != "user" {
			libCode = `
var {name}Namespace = GLOBAL_ENV.EnsureNamespace(MakeSymbol("{ns}"))

func {name}LazyInit() {
	{name}Namespace.Lazy = nil
	processData({name}Data, "{ns}")
}

`[1:]
			setLazy = `
	{name}Namespace.Lazy = {name}LazyInit
`[1:]
			slowInit = `// +build !fast_init
`
		}
		dataTemplate = strings.ReplaceAll(dataTemplate, "{lib-code}", libCode)
		dataTemplate = strings.ReplaceAll(dataTemplate, "{set-lazy}", setLazy)

		namespaces[nsName] = struct{}{}

		name := f.Filename[0 : len(f.Filename)-5] // assumes .joke extension
		fileContent := strings.ReplaceAll(dataTemplate, "{name}", name)
		fileContent = strings.ReplaceAll(fileContent, "{ns}", nsName)
		fileContent = strings.ReplaceAll(fileContent, "{slowInit}", slowInit)
		fileContent = strings.Replace(fileContent, "{content}", string(dst), 1)
		ioutil.WriteFile("a_"+name+"_data.go", []byte(fileContent), 0666)
	}

	const dataTemplate = `// Generated by gen_data. Don't modify manually!

package core

func init() {
	coreNamespaces = []string{
{coreNamespaces}
	}
}
`

	coreNamespaces := []string{}
	for ns, _ := range namespaces {
		coreNamespaces = append(coreNamespaces, fmt.Sprintf(`
		"%s",`[1:],
			ns))
	}
	dataContent := strings.Replace(dataTemplate, "{coreNamespaces}", strings.Join(coreNamespaces, "\n"), 1)
	ioutil.WriteFile("a_data.go", []byte(dataContent), 0666)

	if VerbosityLevel > 0 {
		fmt.Fprintln(os.Stderr, "gen_data:main(): After loading source files:")
		fmt.Fprintf(os.Stderr, "Namespaces=%s\n", namespaces)
		if VerbosityLevel > 1 {
			Spew()
		}
	}
}
