<img src="https://user-images.githubusercontent.com/882970/48048842-a0224080-e151-11e8-8855-642cf5ef3fdd.png" width="117px"/>

# Developer Notes

These notes are intended for developers working on the internals of Joker itself. They are not comprehensive.

## Library Code (Namespaces)

As with Clojure, Joker supports "libraries" of code organized into _namespaces_. It offers a number of namespaces that are built-in to the Joker executable itself, as well as the ability to dynamically (at run time and on-demand) extend these namespaces via external Joker source files typically organized into directory trees and deployed alongside the Joker executable. (Currently, Joker does not support dynamic extension via non-Joker code, such as Go plugins.)

Whether built-in (as described below) or separately deployed via source files written in Joker (as described in [Organizing Libraries (Namespaces)](https://github.com/candid82/joker/LIBRARIES.md), developers should be aware of the progression of any given namespace.

## Namespace States

The states through which a given namespaces transitions are:

1. Available
2. Mapped
3. Loaded

### Available Namespaces

A namespace is _available_ if its source code is either:

* compiled (in some form) directly into the Joker executable
* deployed as Joker code such that a running Joker executable can locate and load it

The _compiled_ namespaces are also the _built-in_ namespaces, and are described below. These start out "mapped", though not necessarily "loaded"; the _core_ namespaces are loaded on-demand when first referenced. (`joker.core` is referenced immediately upon startup of the Joker executable; `joker.repl` is as well, when running Joker as a REPL.)

A namespace that is available, but not mapped, is not found via e.g. `(the-ns 'joker.hiccup)`. The set of _core_ namespaces is hardcoded (in any given Joker executable) in `joker.core/*core-namespaces*`; this list is built automatically from information generated by `core/gen_data/gen_data.go`.

Other built-in namespaces, the so-called _std_ namespaces, start out (like the _core_ namespaces) as both available _and_ mapped.

### Mapped Namespaces

A namespace is _mapped_ if it is present in `(all-ns)`, which enumerates all the namespaces mapped into the current (global) environment.

In this state, the namespace is "registered" (to coin a synonym) with the canonical Clojure namespace mechanism as implemented by Joker.

But the namespace itself hasn't yet necessarily been initialized. Only when that happens (potentially "lazily") is the namespace said to be _loaded_.

### Loaded Namespaces

When actually needed, via a `:require` clause in an `(ns ...)` specification, due to `(require ...)`, or (for an already-mapped namespace) directly as a symbol qualifier via e.g. `joker.some.namespace/somevar`, a namespace is _loaded_, meaning its internal code and data structures are fully initialized.

For example, running Joker with the `--verbose` option to observe some of the pertinent transitions (and with a two-line Joker script in `a/b/c.joke` that does `(ns a.b.c)` and `(println "here i am!")`):

```
$ joker --verbose
processData: Evaluated code for joker.core
NamespaceFor: Lazily initialized joker.core for joker.core
Lazily running slow version of string.InternsOrThunks().
NamespaceFor: Lazily initialized joker.string for FindNameSpace
processData: Evaluated code for joker.repl
NamespaceFor: Lazily initialized joker.repl for FindNameSpace
Welcome to joker v0.14.1. Use EOF (Ctrl-D) or SIGINT (Ctrl-C) to exit.
user=> (all-ns)
(joker.test joker.filepath joker.base64 joker.crypto joker.core joker.better-cond joker.template joker.walk joker.io joker.math joker.set joker.csv joker.html joker.os joker.strconv joker.pprint joker.url joker.tools.cli user joker.http joker.time joker.hiccup joker.repl joker.hex joker.json joker.string joker.yaml)
user=> joker.core/*core-namespaces*
#{joker.tools.cli joker.test user joker.template joker.core joker.walk joker.set joker.repl joker.hiccup joker.pprint joker.better-cond}
user=> (the-ns 'joker.hiccup)
Lazily running slow version of html.InternsOrThunks().
NamespaceFor: Lazily initialized joker.html for FindNameSpace
processData: Evaluated code for joker.hiccup
NamespaceFor: Lazily initialized joker.hiccup for FindNameSpace
#object[Namespace "joker.hiccup"]
user=> (use 'joker.hiccup)
nil
user=> (use 'joker.template)
processData: Evaluated code for joker.walk
NamespaceFor: Lazily initialized joker.walk for FindNameSpace
processData: Evaluated code for joker.template
NamespaceFor: Lazily initialized joker.template for FindNameSpace
nil
user=> (the-ns 'joker.hiccup)
#object[Namespace "joker.hiccup"]
user=> (the-ns 'a.b.c)
<repl>:7:10: Exception: No namespace: a.b.c found
Stacktrace:
  global <repl>:7:1
  core/the-ns <joker.core>:2316:18
user=> (use 'a.b.c)
here i am!
nil
user=> (all-ns)
(joker.walk joker.base64 joker.crypto joker.io joker.math joker.core joker.better-cond joker.template joker.set joker.csv joker.html joker.os joker.strconv joker.pprint joker.url joker.time a.b.c joker.tools.cli user joker.http joker.hiccup joker.repl joker.yaml joker.hex joker.json joker.string joker.test joker.filepath)
user=> (defn all-ns-as-set-of-strings [] (set (map str (all-ns))))
#'user/all-ns-as-set-of-strings
user=> (all-ns-as-set-of-strings)
#{"joker.crypto" "joker.strconv" "joker.pprint" "joker.csv" "joker.io" "joker.string" "joker.url" "joker.template" "joker.core" "joker.tools.cli" "joker.html" "joker.set" "joker.hex" "joker.time" "joker.json" "joker.hiccup" "user" "joker.yaml" "joker.filepath" "joker.repl" "joker.os" "joker.base64" "joker.better-cond" "joker.math" "joker.test" "joker.http" "joker.walk" "a.b.c"}
user=> ((all-ns-as-set-of-strings) "a.b.c")
"a.b.c"
user=> ((all-ns-as-set-of-strings) "joker.foo")
nil
user=> (joker.core/ns-initialized? 'joker.os)
false
user=> (joker.core/ns-initialized? 'joker.hiccup)
true
user=> (joker.core/ns-initialized? 'joker.html)
true
user=> (joker.core/ns-initialized? 'a.b.c)
true
user=>
```

First, note that `joker.string` is lazily initialized. This is due to running Joker as a REPL, because that automatically loads `joker.repl`, which in turn requires `joker.string`.

Then, `(the-ns 'joker.hiccup)` explicitly loads that namespace, meaning that it is initialized. (It needn't be initialized again during this same invocation of Joker.)

Further, because `joker.hiccup` requires `joker.html` (an already-mapped namespace), the latter is _loaded_ (lazily initialized).

A helpful (if longwindedly-named) function is then defined to return a set of all mapped namespaces, as strings, which can in turn be used to easily determine whether a namespace (as a string) is mapped.

The private function `joker.core/ns-initialized?` is then used to test whether various mapped namespaces have been initialized.

Note that, at present, there are no explicit tests for whether a namespace is _available_ (in the general sense). One could attempt to load a namespace with a `(try ...)`, but that would have the (potential) side effect of actually loading the namespace.

These distinctions should be of little, if any, important to developers of Joker code, since these transitions are (largely) managed automatically on behalf of canonical Joker code. But such distinctions are potentially of interest to developers working on Joker internals, including _core_ or _std_ namespaces.

## Built-in Namespaces

As explained in [the `README.md file`](https://github.com/candid82/joker/README.md), Joker provides several built-in namespaces, such as `joker.core`, `joker.math`, `joker.string`, and so on.

All necessary support for these namespaces is included in the Joker executable, so their source code needn't be distributed nor deployed along with Joker. This allows Joker to be deployed as a stand-alone executable.

The built-in namespaces are organized into two sets:

* Core namespaces, which provide functions, macros, and so on necessary for rudimentary functioning of Joker

* Standard-library-wrapping ("_std_") namespaces, which provide Clojure-like interfaces to various Go standard libraries' public APIs

The mechanisms used to incorporate these namespaces into the Joker executable differ substantially, so it is important to understand them when considering adding (or changing) a namespace to the Joker executable.

### Core Namespaces

Core namespaces, starting with `joker.core`, define the features (mostly macros and functions) that are necessary for even rudimentary Joker scripts to run.

Their source code resides in the `core/data/` directory as `*.joke` files.

Not every such file corresponds to a single namespace; the `linter_*.joke` files modify the `joker.core` namespace, while the remaining files do correspond to namespaces, and are named by dropping the `joker.` prefix and changing all `.` characters to `_`. So, for example, the `joker.tools.cli` namespace is defined by `core/data/tools_cli.joke`.

When Joker is built (via the `run.sh` script), `go generate ./...` is first run. Among other things, this causes the following source line (a Go comment) in `core/object.go` to be executed:

```
//go:generate go run gen_data/gen_data.go
```

That builds and runs `core/gen_data/gen_data.go`, which finds, in the `CoreSourceFiles` array defined in `core/procs.go`, a list of files (in `core/data/`) to be processed.

As explained in the block comment just above the `var CoreSourceFiles []...` definition, the files must be ordered so any given file depends solely on files (namespaces) defined above it (earlier in the array).

Processing a `.joke` file consists of reading the file via Joker's (Clojure-like) Reader, "packing" the results into a portable binary format, and encoding the resulting binary data as a Go source file named `core/a_*_data.go`, where `*` is the same as in `core/data/*.joke`.

As this all occurs before the `go build` step performed by `run.sh`, the result is that that step includes those `core/a_*_data.go` source files. The binary data contained therein is, when needed, unpacked and the results used to construct the data structures into which Joker (Clojure) expressions are converted when read (aka the Abstract Syntax Tree, or "AST").

(Note that "when needed", as used above, is immediately upon startup for `joker.core`; it also applies to `joker.repl` when the REPL is to be immediately entered; otherwise, it applies when the namespace is referenced such as via a `require` or `use` invocation.)

As this approach does *not* involve the normal Read phase at Joker startup time, the overhead involved in parsing certain Clojure forms is avoided, in lieu of using (what one assumes would be) faster code paths that convert binary blobs directly to AST forms. But most of Joker's object types (corresponding generally to Clojure forms) are stringized into the binary-data string, and parsed back out at load time; so not all parsing overhead is avoided.

A disadvantage of this approach is that it requires changes to `core/pack.go` when changes are made to certain aspects of the AST.

The generated `core/a_*_data.go` files also cause namespaces (for files corresponding directly to libraries, i.e. not linter-related `.joke` files) to be mapped when Joker is run, and to set their lazy-initialization function (in the `.Lazy` field for the namespace) to point to a function that nulls out that `.Lazy` field and processes the binary data.

#### Building the Fast-Startup Version of Joker

The fast-startup variant of Joker is built by running `core/gen_code/gen_code.go` after `gen_data.go`. It performs similar actions, to read and evaluate the "blobs", yielding fully populated data structures as if all core namespaces (and _std_ namespaces upon which they depend) have been fully loaded in a Joker invocation (though this is done before a proper Joker executable is actually built).

Then, these data structures are compiled into Go code that, when (in turn) compiled into a Joker executable, creates them _in toto_, mostly via static initialization of numerous package-scope variables.

The resulting Joker executable (`joker.fast`, as described below) thus starts up with all the core-namespace-related data structures already nearly-fully populated, with remaining work done via a combination of initialization functions (`func init()`), dynamic-variable initialization (of `*out*`, `*command-line-args*`, etc.), and lazy initialization (such as compiled regular expressions in `joker.hiccup`) when the respective namespaces are actually referenced for the first time during that invocation.

##### Avoid Copying Dynamic Variables

**IMPORTANT:** Because the compiled structures are (mostly) statically initialized in the fast-startup version of Joker, core libraries defining variables whose values depend on dynamic variables might not work properly even when the values are copied by namespaces other than `joker.core` (and thus the values are referenced, in the slow-startup version, only when the namespaces are actually loaded).

The one case that currently exists, `joker.test/*test-out*`, is defined as a copy of `joker.core/*out*`; but the latter is set at runtime (hence the adjective "dynamic"), so `gen_code.go` detects that and specially handles this case by copying the value of it into the value of `*test-out*` only during the lazy-initialization phase of `joker.test`, instead of leaving the assignment performed when `gen_code.go` evaluates the forms generated by `gen_data.go` (at which point in time `*out*` is `nil`).

But the general case of such a reference is neither handled nor detected (though either or both could be implemented if deemed necessary).

So while `(def clargs *command-line-args*)` might work, even though `*command-line-args*` is initialized at runtime, `(def nargs (count *command-line-args*))` might silently always set `nargs` to `0` in the fast-startup version.

Now, this wouldn't work in `joker.core` anyway, because that namespace is always processed (in both variants of Joker) before dynamic variables (such as `*command-line-args*`, `*classpath*`, and so on) are set.

If `nargs` (in the example shown above) is defined in (say) `joker.test`, however, the slow-startup version of Joker will perform that assignment after dynamic variables have been initialized, because that's when it reads in and evaluates the blobs comprising that namespace (once it's referenced).

But the fast-startup version of Joker will have already "baked in" the value of `nargs` when `gen_code.go` ran; there's no runtime code currently generated to dynamically set such a dependent variable after that variable has been set.

This doesn't affect functions that merely _reference_ dynamic variables. E.g. `(defn nargs [] (count *command-line-args*))` would work fine (and `nargs` would be called as a function), since Joker does not compile such forms into Go code in optimized form.

Arguably, copying of dynamic variables is an unwise practice in any case: as highlighted above, the user of a namespace doesn't necessarily control when the namespace code is loaded and any such assignments performed. Providing initialization/reset functions for such namespaces, or simply promoting the desired assignees to functions that simply reference the dynamic variables, is probably better, as these approaches either give the namespace user control over when to perform the copying of values, or obviate the issue.

For a dynamic variable such as `*command-line-args*`, this might not seem important; but for something like `*out*` or `*classpath*`, which user code might change while running, it's important for said user code (or any namespaces it uses) to be able to predict when their values will actually be captured by core namespaces, just as they would be by user-defined (3rd-party) namespaces/libraries.

The list of such dynamic variables is kept in `core/gen_code/gen_code.go`, and is currently:

```
	knownLateInits = map[string]struct{}{
		"joker.core/*in*":                struct{}{},
		"joker.core/*out*":               struct{}{},
		"joker.core/*err*":               struct{}{},
		"joker.core/*command-line-args*": struct{}{},
		"joker.core/*classpath*":         struct{}{},
		"joker.core/*core-namespaces*":   struct{}{},
		"joker.core/*verbose*":           struct{}{},
		"joker.core/*file*":              struct{}{},
		"joker.core/*main-file*":         struct{}{},
	}
```

#### Adding a Core Namespace

Assuming one has determined it appropriate to add a new core namespace to the Joker executable (versus deploying it as a separate `*.joke` file), one must code it up (presumably as Joker code, though some Go code can be added to support it as well).

Then, besides putting that source code in `core/data/*.joke`, one must:

* Add it to the **core/gen\_common/gen\_common.go** `CoreSourceFiles` array (after any core namespaces upon which it depends)

Further, if the new namespace depends on any standard-library-wrapping namespaces:

* Edit the **core/gen\_data/gen\_data.go** `import` statement to include each such library's Go code
* Do the same for **core/gen\_code/gen\_code.go**
* Ensure that code has already been generated (that library's `std/*/a_*.go` file has already been created), perhaps by using an older version of Joker to run `generate-std.joke` from within the `std` subdirectory

(Do not add the namespace to `*loaded-libs*`; that's for only libraries that have already been loaded. It will be automatically added to `*core-namespaces*` as an "available" library; and, upon being loaded, it will be added to `*loaded-libs*`. The fast-startup version of Joker will have already loaded all core libraries upon startup.)

Create suitable tests, e.g. in `tests/eval/`.

Finally, it's time to build as usual (e.g. via `./run.sh`), then run `./eval-tests.sh` or even `./all-tests.sh`.

Note that core libraries (other than `joker.core` and, when running the Repl, `joker.repl`) do not show up in `joker.core/*loaded-libs*` (which is returned by the public function `loaded-libs`) until after they've been loaded via `:require` or similar.

### Standard-library-wrapping (std) Namespaces

These namespaces are also defined by Joker code, which resides in `std/*.joke` files.

(Note that, unlike with core namespaces, multi-level namespaces here would have pathnames reflecting multiple levels. E.g. a `joker.a.b` namespace would be defined by `std/a/b.joke`. However, such namespaces do not exist in Joker as of `v0.14.0`.)

These `*.joke` files, however, have code of a particular form that is processed by the `std/generate-std.joke` script (after an initial version of Joker is built). They cannot, as explained below, define arbitrary macros and functions for use by normal Joker code.

#### The Joker Script That Writes Go Code

The `std/generate-std.joke` script, which is run after the Joker executable is first built (by `run.sh`), reads in the pertinent namespaces, currently defined via `(def namespaces ...)` at the top of the script.

(This should probably be changed to dynamically discover all the `*.joke` files in `std/`. See [the `gostd` fork's version](https://github.com/jcburley/joker/blob/gostd/std/generate-std.joke) for a sample implementation.)

`(apply require namespaces)` loads the target namespaces, then the script processes each namespace in `namespaces` by examining its public members and "compiling" them into Go code, which it stores in `std/*/a_*.go`, where `*` is the same name.

For example, `std/math.joke` is processed such that the resulting Go code is written to `std/math/a_math.go`.

*Note:* This processing does *not* handle arbitrary Joker code! In particular, "logic" (such as `(if ...)`) in function bodies is neither recognized nor handled; it's actually discarded, in that it does not appear (in any form) in the final Joker executable. Similarly, no macros (public or otherwise) appear at all; so, as with logic in functions, they're useful only insofar as they might affect how other public members are defined during the running of `std/generate-std.joke`.

Instead, the processing consists primarily of examining the metadata for each (public) member and emitting Go code that, when built into (the soon-to-be-rebuilt) Joker executable, creates the namespace (`joker.math` in the above example), "interns" the public symbols, and includes (attached to those symbols) both suitable metadata and Go-code "stubs" that handle Joker code referencing a given symbol and the underlying Go implementation (typically a standard-library API, such as `math.sin` for `joker.math/sin`).

Those stubs handle arity, types, and results.

Whether they call Go code directly, or call support code written in Go (typically included in a file named `std/*/*_native.go`, e.g. `std/math/math_native.go`) -- and the specific Go-code invocation used -- is determined via the `:go` metadata and return-type tags for the public member, as defined in the original `std/*.joke` file.

The `a_*.go` files generated for _std_ namespaces cause the namespaces to be _mapped_ by the time the Joker executable has finished starting up. That's why they appear in `(all-ns)`, even when they haven't actually been loaded (lazily initialized).

#### Advantages and Disadvantages vis-a-vis Core Namespaces

As standard-library-wrapping namespaces are lazily loaded (i.e. on-demand), and needn't build up the ASTs that the core namespaces build up, they can be expected (in the standard, not fast-startup, build of Joker) to offer lower overhead at startup and/or first-use time. That is, only namespace generation, interning of symbols, and metadata is built up; other logic is "baked in" via compilation of the Go code accompanying these namespaces.

However, any logic (such as conditionals, loops, and so on) to be performed by them must be expressed in Go, rather than Joker, code; this mechanism is designed for easier creation of "thin" wrappers between Joker and Go code, not as a general mechanism for embedding Joker code in the Joker executable.

Another advantage (besides performance) of this approach is that the resulting code that builds up the target namespace has no dependencies on any other Joker namespaces -- not even on `joker.core`.

That means a *core* namespace may actually depend on one of these (standard-library-wrapping) namespaces, as long as `std/generate-std.joke` has been run and the resulting `std/*/a_*.go` file has been made available in the working directory (e.g. by being added to the Git repository).

*NOTE:* The fast-startup variant of Joker generates two or three `a_*.go` files per namespace, depending on whether the namespace is required by any of the core namespaces. `a_*_slow_init.go` handles the runtime (including "lazy") initialization; if the namespace is required by a core namespace, it's built only for the slow-startup executable, and `a_*_fast_init.go`, built only for the fast-startup executable, handles the corresponding runtime/lazy initialization.

#### Optimizing Build Time

The `run.sh` script includes an optimization that avoids building Joker a second (final) time after it runs `std/generate-std.joke` to generate the `std/*/a_*.joke` files.

That optimization starts by computing a hash of the contents of the `std/` directory *before* running the script, and another one *afterwards*.

If the hashes are identical, `run.sh` assumes nothing has changed in the `std/*.joke` files with respect to the `std/*/a_*.joke` files present prior to running the script, and thus there's no need to rebuild the Joker executable.

(Of course, even if a `std/*.joke` file hasn't changed, any changes to `std/generate-std.joke` or any of the `std/*/*.go` files, handwritten or autogenerated, will result in a different hash being computed and thus a rebuild.)

#### Adding a New Standard-library-wrapping Namespace

Besides creating `std/foo.joke` with appropriate metadata (such as `:go`) for each public member (in `joker.foo`), one must:

* Add `'foo` to the definition of `namespaces` in **std/generate-std.joke**
* Add the namespace to `*loaded-libs*` by editing its `defonce` definition in `core/data/core.joke`
* `mkdir -p std/foo`
* `(cd std; ../joker generate-std.joke)` to create `std/foo/a_foo.go`
* If necessary, write supporting Go code, which goes in `std/foo/foo_native.go` and other Go files in `std/foo/*.go`
* Add the resulting set of Go files, as well as `std/foo.joke`, to the repository
* Add tests to `tests/eval/`
* Rebuild the Joker executable (via `run.sh` or equivalent)
* Run the tests (via `./all-tests.sh` or just `./eval-tests.sh`)

While some might object to the inclusion of generated files (`std/*/a_*.joke`) in the repository, Joker currently depends on their presence in order to build, due to circular dependencies (related to the bootstrapping of Joker) as described below.

### Beware Circular Dependencies

There's actually a circular dependency between the two sets of namespaces:

* `core/gen_data/gen_data.go` imports `std/string` (so `core/gen_code/gen_code.go` does as well), so the initialization code that adds the namespace is run
* `std/string/a_string.go` is generated by `std/generate-std.joke`
* `std/generate-std.joke` is run by the first Joker executable built by `run.sh`
* That Joker executable cannot be built until after `gen_data.go` has been run

This circular dependency is avoided, in practice, by ensuring that any `std/*/a_*.go` files are already generated and present before any new dependencies upon them are added to `gen_data.go`.

However, a `std/*.joke` file therefore cannot depend on any `core/data/*.joke`-defined namespace that, in turn, requires `gen_data.go` to import its `std/*/a_*.go` file.

So, while `joker.repl` and `joker.tools.cli` currently depend on `joker.string`, `std/string.joke` does not depend on them, and preexisted their being added to the core namespaces.

## Faster Startup

Unless the file **NO-OPTIMIZE-STARTUP.flag** exists in the top-level Joker directory, or **OPTIMIZE_STARTUP=false** is set in the environment, **run.sh** builds an extra set of Go source files that, when enabled via a build tag, statically initialize most of the core namespace info (some runtime initialization must stil be performed, due mainly to limitations in the Go compiler).

It then builds both the normal and fast-startup versions of Joker. The normal version is built via `go build` (no build tag specified) and is renamed **joker.slow**. Then the fast-startup version is built via `go build -tags fast_init` and hardlinked to **joker.fast**, leaving **joker** as the fast-startup version.

This fast-startup version is then used to generate the **std** libraries, as is normal. It can also be used to regenerate the documentation, and (ideally) for any other purpose. It should run about as fast as Joker after starting up; very little is overtly added to the runtime cost (a few "thunks" are introduced for some routines, but that should end up in the noise, performance-wise).

### Developer Notes

TBD, but something like this was done to search for Joker code that runs before `main()` and determine how best to handle it in a slow-vs-fast split build:

```
grep --color -nH --null -E -e '^(func init\(|var )' *.go ../*.go ../std/*/*.go | grep -v ' ProcFn = '
```

### Overview of Changes Made to Joker

The fast-startup version necessitated (as of this writing) these changes:

* `Regex` is now `*Regex` (a reference type), mainly so runtime initialization (from a `regexp.MustCompile()` call) can be assigned into the `.Value` or equivalent member of a static structure.
* `internalNamespaceInfo` is a new struct type that wraps `[]byte` for the core namespace, adding `init func()` (the slow version uses this for lazy-loading of core namespaces; might be replaceable via the `.Lazy` mechanism if we always map all core namespaces) and `available bool` (which aids detecting missing `a_*.go` files more elegantly).
* Many (larger/complicated) static vars' definitions and initializations have been separated out into `_init.go` files (e.g. `procs_init.go`, `environment_init.go`, etc.), which are `// +build !fast_init`, in that they aren't built into the fast-startup version of Joker.
* `Proc` now wraps the former `Proc` (renamed `ProcFn`) and adds self-identifying info (the name of the procedure and its package), to help code generation when it encounters them.
* Thunks are (unfortunately) necessary for `ProcFn`’s that, directly or indirectly (but statically), reference static variables such as `GLOBAL_ENV`, else the Go compiler refuses to compile the fast code due to cycles (!!).
* A new `core/gen_code/gen_code.go` program parallels (and is run after the running of) `gen_data.go`. It generates `a_*code.go` files that mostly define static variables representing the structures resulting when loading `joker.core` and the like; these are `// +build fast_init`, so they are compiled only when building the fast-startup version of Joker.
* `gen_data.go` changes include:
    - The list of files (`FileInfo`) has been moved into `procs.go` (might not be the best place, maybe `common.go` or a new file?) as `CoreSourceFiles` so `gen_code.go` can share it.
    - `// +build !fast_init` is emitted in pertinent files (mainly the `a_*_data.go` files, but not `a_data.go` itself).
    - Support for a `--verbose` option.
* The new `run.sh` defaults to running `gen_code.go`, which takes about only a few seconds on my Ryzen 3, and which generates these static-initializing files, built only when `-tags fast_init` is specified.
* `run.sh` continues on to building both the “normal” (slower) Joker, renamed to `joker.slow`, and the fast-startup version, hardlinked to `joker.fast`, which thus becomes the default for subsequent use (such as running `std/generate-std.joke` and then running the executable itself with whatever arguments were provided to `run.sh`).
* A new `core/code.go` module is (now) mainly a helper for `gen_code.go`, since the latter isn’t part of `package core`.
* A rudimentary tracing facility is enabled via `--trace`, mainly useful for my debugging this work, but not particularly elegant as-is; it is accompanied by a `--max-depth N` option.
* `*verbosity-level*` and related stuff was introduced, also for debugging.
* Beyond verbosity level 1 (sometimes 2), various things are “spewed” (via go-spew) at appropriate times. (Of course, this works only if Joker was built with `-tags go_spew`.)
* The new private function `joker.core/ns-init?` tells whether a namespace has been initialized (fully, including potentially lazily, loaded), useful as a debugging tool.

## Debugging Tools

### go-spew

When built via e.g. `go builds -tags go_spew`, the private `joker.core/go-spew` function is enabled. (Otherwise it does nothing and returns `false`.)

This function dumps, to `stderr`, the internal structure of the argument passed to it (i.e. a Joker object), and returns `true`.

Optionally, a second argument may be specified that is a map with configuration options as described in [the `go-spew` documentation](https://github.com/jcburley/go-spew), though not all such operations are yet supported by Joker's `go-spew` function.

For example, the internals of the keyword `:hey` can be output in this fashion:

```
user=> (joker.core/go-spew :hey {:MaxDepth 5 :Indent "    " :UseOrdinals true})
(core.Keyword) {
    InfoHolder: (core.InfoHolder) {
        info: (*core.ObjectInfo)(#1)({
            Position: (core.Position) {
                endLine: (int) 1,
                endColumn: (int) 24,
                startLine: (int) 1,
                startColumn: (int) 21,
                filename: (*string)(#2)((len=6) "<repl>")
            }
        })
    },
    ns: (*string)(<nil>),
    name: (*string)(#3)((len=3) "hey"),
    hash: (uint32) 819820356
}
true
user=>
```

*Note:* The `SpewState` configuration option is not currently supported; each distinct call to `go-spew` thus starts with a "fresh" state.
