// This file is generated by generate-std.joke script. Do not edit manually!

package os

import (
	. "github.com/candid82/joker/core"
	"os"
)

var osNamespace = GLOBAL_ENV.EnsureNamespace(MakeSymbol("joker.os"))

var __args__P ProcFn = __args_
var args_ Proc = Proc{Fn: __args__P, Name: "args_"}

func __args_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 0:
		_res := commandArgs()
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __chdir__P ProcFn = __chdir_
var chdir_ Proc = Proc{Fn: __chdir__P, Name: "chdir_"}

func __chdir_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		dirname := ExtractString(_args, 0)
		_res := chdir(dirname)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __close__P ProcFn = __close_
var close_ Proc = Proc{Fn: __close__P, Name: "close_"}

func __close_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		f := ExtractFile(_args, 0)
		err := f.Close()
		PanicOnErr(err)
		_res := NIL
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __create__P ProcFn = __create_
var create_ Proc = Proc{Fn: __create__P, Name: "create_"}

func __create_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		name := ExtractString(_args, 0)
		_res, err := os.Create(name)
		PanicOnErr(err)
		return MakeFile(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var __cwd__P ProcFn = __cwd_
var cwd_ Proc = Proc{Fn: __cwd__P, Name: "cwd_"}

func __cwd_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 0:
		_res := getwd()
		return MakeString(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var __env__P ProcFn = __env_
var env_ Proc = Proc{Fn: __env__P, Name: "env_"}

func __env_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 0:
		_res := env()
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __exec__P ProcFn = __exec_
var exec_ Proc = Proc{Fn: __exec__P, Name: "exec_"}

func __exec_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		name := ExtractString(_args, 0)
		opts := ExtractMap(_args, 1)
		_res := execute(name, opts)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __isexists__P ProcFn = __isexists_
var isexists_ Proc = Proc{Fn: __isexists__P, Name: "isexists_"}

func __isexists_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		path := ExtractString(_args, 0)
		_res := exists(path)
		return MakeBoolean(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var __exit__P ProcFn = __exit_
var exit_ Proc = Proc{Fn: __exit__P, Name: "exit_"}

func __exit_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		code := ExtractInt(_args, 0)
		_res := NIL
		ExitJoker(code)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __ls__P ProcFn = __ls_
var ls_ Proc = Proc{Fn: __ls__P, Name: "ls_"}

func __ls_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		dirname := ExtractString(_args, 0)
		_res := readDir(dirname)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __mkdir__P ProcFn = __mkdir_
var mkdir_ Proc = Proc{Fn: __mkdir__P, Name: "mkdir_"}

func __mkdir_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		name := ExtractString(_args, 0)
		perm := ExtractInt(_args, 1)
		_res := mkdir(name, perm)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __open__P ProcFn = __open_
var open_ Proc = Proc{Fn: __open__P, Name: "open_"}

func __open_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		name := ExtractString(_args, 0)
		_res, err := os.Open(name)
		PanicOnErr(err)
		return MakeFile(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var __remove__P ProcFn = __remove_
var remove_ Proc = Proc{Fn: __remove__P, Name: "remove_"}

func __remove_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		name := ExtractString(_args, 0)
		err := os.Remove(name)
		PanicOnErr(err)
		_res := NIL
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __remove_all__P ProcFn = __remove_all_
var remove_all_ Proc = Proc{Fn: __remove_all__P, Name: "remove_all_"}

func __remove_all_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		path := ExtractString(_args, 0)
		err := os.RemoveAll(path)
		PanicOnErr(err)
		_res := NIL
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __set_env__P ProcFn = __set_env_
var set_env_ Proc = Proc{Fn: __set_env__P, Name: "set_env_"}

func __set_env_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		key := ExtractString(_args, 0)
		value := ExtractString(_args, 1)
		_res := setEnv(key, value)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __sh__P ProcFn = __sh_
var sh_ Proc = Proc{Fn: __sh__P, Name: "sh_"}

func __sh_(_args []Object) Object {
	_c := len(_args)
	switch {
	case true:
		CheckArity(_args, 1, 999)
		name := ExtractString(_args, 0)
		arguments := ExtractStrings(_args, 1)
		_res := sh("", nil, nil, nil, name, arguments)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __sh_from__P ProcFn = __sh_from_
var sh_from_ Proc = Proc{Fn: __sh_from__P, Name: "sh_from_"}

func __sh_from_(_args []Object) Object {
	_c := len(_args)
	switch {
	case true:
		CheckArity(_args, 2, 999)
		dir := ExtractString(_args, 0)
		name := ExtractString(_args, 1)
		arguments := ExtractStrings(_args, 2)
		_res := sh(dir, nil, nil, nil, name, arguments)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var __stat__P ProcFn = __stat_
var stat_ Proc = Proc{Fn: __stat__P, Name: "stat_"}

func __stat_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		filename := ExtractString(_args, 0)
		_res := stat(filename)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

func Init() {

	osNamespace.ResetMeta(MakeMeta(nil, `Provides a platform-independent interface to operating system functionality.`, "1.0"))

	osNamespace.InternVar("args", args_,
		MakeMeta(
			NewListFrom(NewVectorFrom()),
			`Returns a sequence of the command line arguments, starting with the program name (normally, joker).`, "1.0"))

	osNamespace.InternVar("chdir", chdir_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("dirname"))),
			`Chdir changes the current working directory to the named directory. If there is an error, an exception will be thrown. Returns nil.`, "1.0"))

	osNamespace.InternVar("close", close_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("f"))),
			`Closes the file, rendering it unusable for I/O.`, "1.0"))

	osNamespace.InternVar("create", create_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("name"))),
			`Creates the named file with mode 0666 (before umask), truncating it if it already exists.`, "1.0").Plus(MakeKeyword("tag"), String{S: "File"}))

	osNamespace.InternVar("cwd", cwd_,
		MakeMeta(
			NewListFrom(NewVectorFrom()),
			`Returns a rooted path name corresponding to the current directory. If the current directory can
  be reached via multiple paths (due to symbolic links), cwd may return any one of them.`, "1.0").Plus(MakeKeyword("tag"), String{S: "String"}))

	osNamespace.InternVar("env", env_,
		MakeMeta(
			NewListFrom(NewVectorFrom()),
			`Returns a map representing the environment.`, "1.0"))

	osNamespace.InternVar("exec", exec_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("name"), MakeSymbol("opts"))),
			`Executes the named program with the given arguments. opts is a map with the following keys (all optional):
  :args - vector of arguments (all arguments must be strings),
  :dir - if specified, working directory will be set to this value before executing the program,
  :stdin - if specified, provides stdin for the program. Can be either a string or an IOReader.
  If it's a string, the string's content will serve as stdin for the program. IOReader can be, for example,
  *in* (in which case Joker's stdin will be redirected to the program's stdin) or the value returned by (joker.os/open).
  :stdout - if specified, must be an IOWriter. It can be, for example, *out* (in which case the program's stdout will be redirected
  to Joker's stdout) or the value returned by (joker.os/create).
  :stderr - the same as :stdout, but for stderr.
  Returns a map with the following keys:
  :success - whether or not the execution was successful,
  :err-msg (present iff :success if false) - string capturing error object returned by Go runtime
  :exit - exit code of program (or attempt to execute it),
  :out - string capturing stdout of the program (unless :stdout option was passed)
  :err - string capturing stderr of the program (unless :stderr option was passed).`, "1.0"))

	osNamespace.InternVar("exists?", isexists_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("path"))),
			`Returns true if file or directory with the given path exists. Otherwise returns false.`, "1.0").Plus(MakeKeyword("tag"), String{S: "Boolean"}))

	osNamespace.InternVar("exit", exit_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("code"))),
			`Causes the current program to exit with the given status code.`, "1.0"))

	osNamespace.InternVar("ls", ls_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("dirname"))),
			`Reads the directory named by dirname and returns a list of directory entries sorted by filename.`, "1.0"))

	osNamespace.InternVar("mkdir", mkdir_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("name"), MakeSymbol("perm"))),
			`Creates a new directory with the specified name and permission bits.`, "1.0"))

	osNamespace.InternVar("open", open_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("name"))),
			`Opens the named file for reading. If successful, the file can be used for reading;
  the associated file descriptor has mode O_RDONLY.`, "1.0").Plus(MakeKeyword("tag"), String{S: "File"}))

	osNamespace.InternVar("remove", remove_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("name"))),
			`Removes the named file or (empty) directory.`, "1.0"))

	osNamespace.InternVar("remove-all", remove_all_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("path"))),
			`Removes path and any children it contains.

  It removes everything it can, then panics with the first error (if
  any) it encountered.`, "1.0"))

	osNamespace.InternVar("set-env", set_env_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("key"), MakeSymbol("value"))),
			`Sets the specified key to the specified value in the environment.`, "1.0"))

	osNamespace.InternVar("sh", sh_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("name"), MakeSymbol("&"), MakeSymbol("arguments"))),
			`Executes the named program with the given arguments. Returns a map with the following keys:
      :success - whether or not the execution was successful,
      :err-msg (present iff :success if false) - string capturing error object returned by Go runtime
      :exit - exit code of program (or attempt to execute it),
      :out - string capturing stdout of the program,
      :err - string capturing stderr of the program.`, "1.0"))

	osNamespace.InternVar("sh-from", sh_from_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("dir"), MakeSymbol("name"), MakeSymbol("&"), MakeSymbol("arguments"))),
			`Executes the named program with the given arguments and working directory set to dir.
  Returns a map with the following keys:
      :success - whether or not the execution was successful,
      :err-msg (present iff :success if false) - string capturing error object returned by Go runtime
      :exit - exit code of program (or attempt to execute it),
      :out - string capturing stdout of the program,
      :err - string capturing stderr of the program.`, "1.0"))

	osNamespace.InternVar("stat", stat_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("filename"))),
			`Returns a map describing the named file. The info map has the following attributes:
  :name - base name of the file
  :size - length in bytes for regular files; system-dependent for others
  :mode - file mode bits
  :modtime - modification time
  :dir? - true if file is a directory`, "1.0"))

}

func init() {
	osNamespace.Lazy = Init
}
